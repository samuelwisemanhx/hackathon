# Story 1.3: User Registration Endpoint

## Status
Draft

## Story
**As a** new user,
**I want** to register an account with email and password,
**so that** I can access the assessment application.

## Acceptance Criteria

1. POST `/api/auth/register` endpoint accepts email and password
2. Email validation ensures valid format and uniqueness (returns error if email already exists)
3. Password validation requires minimum 8 characters
4. Password is hashed using bcrypt or argon2 before storage
5. Successful registration creates user record and returns success response (no auto-login)
6. Appropriate error responses for validation failures (400) and duplicate emails (409)
7. Endpoint includes basic rate limiting to prevent abuse
8. Unit tests cover validation logic and error cases

## Tasks / Subtasks

- [ ] Create registration API route (AC: 1)
  - [ ] Create `/src/routes/api/auth/register/+server.ts`
  - [ ] Implement POST handler function
  - [ ] Set up proper CORS and content-type headers

- [ ] Implement request validation (AC: 2, 3)
  - [ ] Create Zod schema for registration request (email + password)
  - [ ] Validate email format using email validator
  - [ ] Validate password minimum length (8 characters)
  - [ ] Return 400 Bad Request for validation failures with specific error messages

- [ ] Implement email uniqueness check (AC: 2, 6)
  - [ ] Query database to check if email already exists
  - [ ] Return 409 Conflict if email is already registered
  - [ ] Include helpful error message (e.g., "Email already registered")

- [ ] Implement password hashing (AC: 4)
  - [ ] Install bcrypt or argon2 package
  - [ ] Hash password before database insert
  - [ ] Use appropriate salt rounds / security parameters
  - [ ] Never store plaintext passwords

- [ ] Create user in database (AC: 5)
  - [ ] Insert user record with email and password_hash
  - [ ] Let database generate UUID and timestamps
  - [ ] Return success response with user data (exclude password_hash)
  - [ ] Return 201 Created status code

- [ ] Implement error handling (AC: 6)
  - [ ] Wrap all logic in try-catch block
  - [ ] Return standardized error format: `{error: {code, message, details}}`
  - [ ] Handle database errors gracefully
  - [ ] Log errors for debugging

- [ ] Add rate limiting (AC: 7)
  - [ ] Implement basic rate limiting middleware/logic
  - [ ] Limit registration attempts per IP (e.g., 5 per hour)
  - [ ] Return 429 Too Many Requests when limit exceeded

- [ ] Write comprehensive tests (AC: 8)
  - [ ] Test successful registration flow
  - [ ] Test invalid email format rejection
  - [ ] Test password too short rejection
  - [ ] Test duplicate email rejection (409)
  - [ ] Test password is hashed (not stored as plaintext)
  - [ ] Test error response format
  - [ ] Test rate limiting behavior

## Dev Notes

### CRITICAL ARCHITECTURAL CONFLICT

**⚠️ MAJOR DISCREPANCY:** Epic specifies traditional auth with registration/login, but architecture uses simplified MVP approach:

**Epic says:**
- POST `/api/auth/register` with email + password
- Traditional session-based authentication

**Architecture says:** [Source: architecture/api-specification.md]
- POST `/api/auth/identify` with email only
- "MVP only - no authentication"
- Email stored in cookie, no passwords

[Source: architecture/tech-stack.md]
- "Authentication | Email-only (MVP) | Temporary user identification | no passwords, no sessions, just email in cookie"

**Resolution:**
As Scrum Master, I recommend **implementing the epic as written** (traditional auth with `/auth/register` endpoint) since that represents approved requirements. The architecture documentation appears outdated or represents a different MVP scope than what was approved in the PRD epics.

**Action Items:**
1. Dev agent should implement `/auth/register` per epic AC
2. After implementation, Product Owner should review and decide:
   - Update architecture docs to match implementation, OR
   - Revise epic to use simplified email-only auth
3. DO NOT implement both `/auth/register` AND `/auth/identify` - choose one approach

**For this story:** Implement `/api/auth/register` exactly as specified in acceptance criteria.

### Previous Story Insights
[Source: Story 1.2]
- Users table includes: id, email, password_hash, created_at, updated_at
- Sessions table created for session management
- Database schema supports traditional authentication

### API Endpoint Pattern
[Source: architecture/coding-standards.md#critical-fullstack-rules]

**SvelteKit API Route Structure:**
- File: `src/routes/api/auth/register/+server.ts`
- Export POST function as named export
- Use `@sveltejs/kit` helpers (json, error)
- Naming: kebab-case for routes

**Standard API Response Format:**
```typescript
// Success
return json({
  user: { id, email, createdAt }
}, { status: 201 });

// Error
return json({
  error: {
    code: 'EMAIL_EXISTS',
    message: 'Email already registered',
    details: { email }
  }
}, { status: 409 });
```

### Request Validation
[Source: architecture/tech-stack.md]

**Validation Library:** Zod (latest)
- Type-safe validation
- Shared between client and server
- Integrates with SvelteKit

**Validation Schema Example:**
```typescript
import { z } from 'zod';

const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

export type RegisterRequest = z.infer<typeof registerSchema>;
```

### Password Hashing
[Source: architecture/tech-stack.md, architecture/database-schema.md]

**Recommended:** bcrypt or argon2

**bcrypt Example:**
```typescript
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 10;
const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
```

**argon2 Example (more secure):**
```typescript
import argon2 from 'argon2';

const passwordHash = await argon2.hash(password);
```

**Security Requirements:**
- NEVER store passwords in plaintext
- Use appropriate salt rounds (bcrypt: 10-12, argon2: defaults are good)
- Hash on server-side only
- Return user data WITHOUT password_hash field

### Database Operations
[Source: Story 1.2, architecture/database-schema.md]

**Repository Pattern:** [Source: architecture/coding-standards.md#critical-fullstack-rules]
"All database access through repository pattern - NEVER write raw SQL in API routes"

**User Repository Location:** `src/lib/server/repositories/user.ts`

**Create User Function:**
```typescript
// src/lib/server/repositories/user.ts
import { db } from '$lib/server/db';
import { users } from '$lib/server/db/schema';
import { eq } from 'drizzle-orm';

export async function findUserByEmail(email: string) {
  const [user] = await db.select().from(users).where(eq(users.email, email));
  return user;
}

export async function createUser(email: string, passwordHash: string) {
  const [newUser] = await db.insert(users).values({
    email,
    passwordHash,
  }).returning();
  return newUser;
}
```

### Rate Limiting

**Simple In-Memory Rate Limiting:**
```typescript
// src/lib/server/utils/rate-limit.ts
const attempts = new Map<string, { count: number; resetAt: number }>();

export function checkRateLimit(ip: string, maxAttempts = 5, windowMs = 3600000) {
  const now = Date.now();
  const record = attempts.get(ip);

  if (!record || now > record.resetAt) {
    attempts.set(ip, { count: 1, resetAt: now + windowMs });
    return true;
  }

  if (record.count >= maxAttempts) {
    return false;
  }

  record.count++;
  return true;
}
```

**Note:** For production, use a proper rate limiting solution (e.g., Redis-based). This is MVP-acceptable.

### Complete Endpoint Implementation Example

```typescript
// src/routes/api/auth/register/+server.ts
import { json } from '@sveltejs/kit';
import { z } from 'zod';
import bcrypt from 'bcrypt';
import { findUserByEmail, createUser } from '$lib/server/repositories/user';
import { checkRateLimit } from '$lib/server/utils/rate-limit';
import type { RequestHandler } from './$types';

const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

export const POST: RequestHandler = async ({ request, getClientAddress }) => {
  try {
    // Rate limiting
    const clientIp = getClientAddress();
    if (!checkRateLimit(clientIp, 5, 3600000)) {
      return json({
        error: {
          code: 'RATE_LIMIT_EXCEEDED',
          message: 'Too many registration attempts. Please try again later.',
          details: {}
        }
      }, { status: 429 });
    }

    // Parse and validate request
    const body = await request.json();
    const validation = registerSchema.safeParse(body);

    if (!validation.success) {
      return json({
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid request data',
          details: validation.error.flatten()
        }
      }, { status: 400 });
    }

    const { email, password } = validation.data;

    // Check email uniqueness
    const existingUser = await findUserByEmail(email);
    if (existingUser) {
      return json({
        error: {
          code: 'EMAIL_EXISTS',
          message: 'Email already registered',
          details: { email }
        }
      }, { status: 409 });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 10);

    // Create user
    const newUser = await createUser(email, passwordHash);

    // Return success (without password_hash)
    return json({
      user: {
        id: newUser.id,
        email: newUser.email,
        createdAt: newUser.createdAt
      }
    }, { status: 201 });

  } catch (error) {
    console.error('Registration error:', error);
    return json({
      error: {
        code: 'INTERNAL_ERROR',
        message: 'An error occurred during registration',
        details: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 500 });
  }
};
```

### Project Structure
[Source: architecture/unified-project-structure.md]

**Files to Create:**
- `src/routes/api/auth/register/+server.ts` - API route
- `src/lib/server/repositories/user.ts` - User database operations
- `src/lib/server/utils/rate-limit.ts` - Rate limiting utility (optional, can be inline)
- `src/lib/types/index.ts` - Add RegisterRequest, RegisterResponse types

### Error Response Standards
[Source: architecture/coding-standards.md#critical-fullstack-rules]

**All API routes must use try-catch and return `{error: {code, message, details}}` format**

**Standard Error Codes:**
- `VALIDATION_ERROR` (400) - Invalid input data
- `EMAIL_EXISTS` (409) - Duplicate email
- `RATE_LIMIT_EXCEEDED` (429) - Too many attempts
- `INTERNAL_ERROR` (500) - Server error

### Testing

**Testing Framework:** Vitest [Source: architecture/tech-stack.md]
**Test Location:** `tests/api/auth/register.test.ts`

**Test Coverage Requirements:**

1. **Successful Registration:**
   - Valid email and password
   - Returns 201 Created
   - Returns user object without password
   - User created in database

2. **Email Validation:**
   - Invalid email format returns 400
   - Empty email returns 400
   - Error message specifies email issue

3. **Password Validation:**
   - Password < 8 characters returns 400
   - Empty password returns 400
   - Error message specifies password requirement

4. **Email Uniqueness:**
   - Duplicate email returns 409
   - Error code is EMAIL_EXISTS
   - Original user unchanged

5. **Password Security:**
   - Password is hashed (not plaintext in DB)
   - password_hash not returned in response
   - bcrypt.compare works with stored hash

6. **Rate Limiting:**
   - 5 attempts succeed
   - 6th attempt returns 429
   - Rate limit resets after time window

7. **Error Format:**
   - All errors have {error: {code, message, details}} structure
   - Appropriate HTTP status codes

**Testing Pattern:**
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { POST } from './+server';
import { db } from '$lib/server/db';
import { users } from '$lib/server/db/schema';

describe('POST /api/auth/register', () => {
  beforeEach(async () => {
    // Clear test data
  });

  it('should register new user with valid email and password', async () => {
    // Test implementation
  });

  // Additional tests...
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
