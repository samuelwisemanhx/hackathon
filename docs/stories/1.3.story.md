# Story 1.3: User Registration Endpoint

## Status
Ready for Review

## Story
**As a** new user,
**I want** to register an account with email and password,
**so that** I can access the assessment application.

## Acceptance Criteria

1. POST `/api/auth/register` endpoint accepts email and password
2. Email validation ensures valid format and uniqueness (returns error if email already exists)
3. Password validation requires minimum 8 characters
4. Password is hashed using bcrypt or argon2 before storage
5. Successful registration creates user record and returns success response (no auto-login)
6. Appropriate error responses for validation failures (400) and duplicate emails (409)
7. Endpoint includes basic rate limiting to prevent abuse
8. Unit tests cover validation logic and error cases

## Tasks / Subtasks

- [x] Create registration API route (AC: 1)
  - [x] Create `/src/routes/api/auth/register/+server.ts`
  - [x] Implement POST handler function
  - [x] Set up proper CORS and content-type headers

- [x] Implement request validation (AC: 2, 3)
  - [x] Create Zod schema for registration request (email + password)
  - [x] Validate email format using email validator
  - [x] Validate password minimum length (8 characters)
  - [x] Return 400 Bad Request for validation failures with specific error messages

- [x] Implement email uniqueness check (AC: 2, 6)
  - [x] Query database to check if email already exists
  - [x] Return 409 Conflict if email is already registered
  - [x] Include helpful error message (e.g., "Email already registered")

- [x] Implement password hashing (AC: 4)
  - [x] Install bcrypt or argon2 package
  - [x] Hash password before database insert
  - [x] Use appropriate salt rounds / security parameters
  - [x] Never store plaintext passwords

- [x] Create user in database (AC: 5)
  - [x] Insert user record with email and password_hash
  - [x] Let database generate UUID and timestamps
  - [x] Return success response with user data (exclude password_hash)
  - [x] Return 201 Created status code

- [x] Implement error handling (AC: 6)
  - [x] Wrap all logic in try-catch block
  - [x] Return standardized error format: `{error: {code, message, details}}`
  - [x] Handle database errors gracefully
  - [x] Log errors for debugging

- [x] Add rate limiting (AC: 7)
  - [x] Implement basic rate limiting middleware/logic
  - [x] Limit registration attempts per IP (e.g., 5 per hour)
  - [x] Return 429 Too Many Requests when limit exceeded

- [x] Write comprehensive tests (AC: 8)
  - [x] Test successful registration flow
  - [x] Test invalid email format rejection
  - [x] Test password too short rejection
  - [x] Test duplicate email rejection (409)
  - [x] Test password is hashed (not stored as plaintext)
  - [x] Test error response format
  - [x] Test rate limiting behavior

## Dev Notes

### CRITICAL ARCHITECTURAL CONFLICT

**⚠️ MAJOR DISCREPANCY:** Epic specifies traditional auth with registration/login, but architecture uses simplified MVP approach:

**Epic says:**
- POST `/api/auth/register` with email + password
- Traditional session-based authentication

**Architecture says:** [Source: architecture/api-specification.md]
- POST `/api/auth/identify` with email only
- "MVP only - no authentication"
- Email stored in cookie, no passwords

[Source: architecture/tech-stack.md]
- "Authentication | Email-only (MVP) | Temporary user identification | no passwords, no sessions, just email in cookie"

**Resolution:**
As Scrum Master, I recommend **implementing the epic as written** (traditional auth with `/auth/register` endpoint) since that represents approved requirements. The architecture documentation appears outdated or represents a different MVP scope than what was approved in the PRD epics.

**Action Items:**
1. Dev agent should implement `/auth/register` per epic AC
2. After implementation, Product Owner should review and decide:
   - Update architecture docs to match implementation, OR
   - Revise epic to use simplified email-only auth
3. DO NOT implement both `/auth/register` AND `/auth/identify` - choose one approach

**For this story:** Implement `/api/auth/register` exactly as specified in acceptance criteria.

### Previous Story Insights
[Source: Story 1.2]
- Users table includes: id, email, password_hash, created_at, updated_at
- Sessions table created for session management
- Database schema supports traditional authentication

### API Endpoint Pattern
[Source: architecture/coding-standards.md#critical-fullstack-rules]

**SvelteKit API Route Structure:**
- File: `src/routes/api/auth/register/+server.ts`
- Export POST function as named export
- Use `@sveltejs/kit` helpers (json, error)
- Naming: kebab-case for routes

**Standard API Response Format:**
```typescript
// Success
return json({
  user: { id, email, createdAt }
}, { status: 201 });

// Error
return json({
  error: {
    code: 'EMAIL_EXISTS',
    message: 'Email already registered',
    details: { email }
  }
}, { status: 409 });
```

### Request Validation
[Source: architecture/tech-stack.md]

**Validation Library:** Zod (latest)
- Type-safe validation
- Shared between client and server
- Integrates with SvelteKit

**Validation Schema Example:**
```typescript
import { z } from 'zod';

const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

export type RegisterRequest = z.infer<typeof registerSchema>;
```

### Password Hashing
[Source: architecture/tech-stack.md, architecture/database-schema.md]

**Recommended:** bcrypt or argon2

**bcrypt Example:**
```typescript
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 10;
const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
```

**argon2 Example (more secure):**
```typescript
import argon2 from 'argon2';

const passwordHash = await argon2.hash(password);
```

**Security Requirements:**
- NEVER store passwords in plaintext
- Use appropriate salt rounds (bcrypt: 10-12, argon2: defaults are good)
- Hash on server-side only
- Return user data WITHOUT password_hash field

### Database Operations
[Source: Story 1.2, architecture/database-schema.md]

**Repository Pattern:** [Source: architecture/coding-standards.md#critical-fullstack-rules]
"All database access through repository pattern - NEVER write raw SQL in API routes"

**User Repository Location:** `src/lib/server/repositories/user.ts`

**Create User Function:**
```typescript
// src/lib/server/repositories/user.ts
import { db } from '$lib/server/db';
import { users } from '$lib/server/db/schema';
import { eq } from 'drizzle-orm';

export async function findUserByEmail(email: string) {
  const [user] = await db.select().from(users).where(eq(users.email, email));
  return user;
}

export async function createUser(email: string, passwordHash: string) {
  const [newUser] = await db.insert(users).values({
    email,
    passwordHash,
  }).returning();
  return newUser;
}
```

### Rate Limiting

**Simple In-Memory Rate Limiting:**
```typescript
// src/lib/server/utils/rate-limit.ts
const attempts = new Map<string, { count: number; resetAt: number }>();

export function checkRateLimit(ip: string, maxAttempts = 5, windowMs = 3600000) {
  const now = Date.now();
  const record = attempts.get(ip);

  if (!record || now > record.resetAt) {
    attempts.set(ip, { count: 1, resetAt: now + windowMs });
    return true;
  }

  if (record.count >= maxAttempts) {
    return false;
  }

  record.count++;
  return true;
}
```

**Note:** For production, use a proper rate limiting solution (e.g., Redis-based). This is MVP-acceptable.

### Complete Endpoint Implementation Example

```typescript
// src/routes/api/auth/register/+server.ts
import { json } from '@sveltejs/kit';
import { z } from 'zod';
import bcrypt from 'bcrypt';
import { findUserByEmail, createUser } from '$lib/server/repositories/user';
import { checkRateLimit } from '$lib/server/utils/rate-limit';
import type { RequestHandler } from './$types';

const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

export const POST: RequestHandler = async ({ request, getClientAddress }) => {
  try {
    // Rate limiting
    const clientIp = getClientAddress();
    if (!checkRateLimit(clientIp, 5, 3600000)) {
      return json({
        error: {
          code: 'RATE_LIMIT_EXCEEDED',
          message: 'Too many registration attempts. Please try again later.',
          details: {}
        }
      }, { status: 429 });
    }

    // Parse and validate request
    const body = await request.json();
    const validation = registerSchema.safeParse(body);

    if (!validation.success) {
      return json({
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid request data',
          details: validation.error.flatten()
        }
      }, { status: 400 });
    }

    const { email, password } = validation.data;

    // Check email uniqueness
    const existingUser = await findUserByEmail(email);
    if (existingUser) {
      return json({
        error: {
          code: 'EMAIL_EXISTS',
          message: 'Email already registered',
          details: { email }
        }
      }, { status: 409 });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 10);

    // Create user
    const newUser = await createUser(email, passwordHash);

    // Return success (without password_hash)
    return json({
      user: {
        id: newUser.id,
        email: newUser.email,
        createdAt: newUser.createdAt
      }
    }, { status: 201 });

  } catch (error) {
    console.error('Registration error:', error);
    return json({
      error: {
        code: 'INTERNAL_ERROR',
        message: 'An error occurred during registration',
        details: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 500 });
  }
};
```

### Project Structure
[Source: architecture/unified-project-structure.md]

**Files to Create:**
- `src/routes/api/auth/register/+server.ts` - API route
- `src/lib/server/repositories/user.ts` - User database operations
- `src/lib/server/utils/rate-limit.ts` - Rate limiting utility (optional, can be inline)
- `src/lib/types/index.ts` - Add RegisterRequest, RegisterResponse types

### Error Response Standards
[Source: architecture/coding-standards.md#critical-fullstack-rules]

**All API routes must use try-catch and return `{error: {code, message, details}}` format**

**Standard Error Codes:**
- `VALIDATION_ERROR` (400) - Invalid input data
- `EMAIL_EXISTS` (409) - Duplicate email
- `RATE_LIMIT_EXCEEDED` (429) - Too many attempts
- `INTERNAL_ERROR` (500) - Server error

### Testing

**Testing Framework:** Vitest [Source: architecture/tech-stack.md]
**Test Location:** `tests/api/auth/register.test.ts`

**Test Coverage Requirements:**

1. **Successful Registration:**
   - Valid email and password
   - Returns 201 Created
   - Returns user object without password
   - User created in database

2. **Email Validation:**
   - Invalid email format returns 400
   - Empty email returns 400
   - Error message specifies email issue

3. **Password Validation:**
   - Password < 8 characters returns 400
   - Empty password returns 400
   - Error message specifies password requirement

4. **Email Uniqueness:**
   - Duplicate email returns 409
   - Error code is EMAIL_EXISTS
   - Original user unchanged

5. **Password Security:**
   - Password is hashed (not plaintext in DB)
   - password_hash not returned in response
   - bcrypt.compare works with stored hash

6. **Rate Limiting:**
   - 5 attempts succeed
   - 6th attempt returns 429
   - Rate limit resets after time window

7. **Error Format:**
   - All errors have {error: {code, message, details}} structure
   - Appropriate HTTP status codes

**Testing Pattern:**
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { POST } from './+server';
import { db } from '$lib/server/db';
import { users } from '$lib/server/db/schema';

describe('POST /api/auth/register', () => {
  beforeEach(async () => {
    // Clear test data
  });

  it('should register new user with valid email and password', async () => {
    // Test implementation
  });

  // Additional tests...
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929[1m])

### Debug Log References
No issues encountered during implementation.

### Completion Notes List
- Successfully implemented user registration endpoint with comprehensive validation
- Implemented bcrypt password hashing with 10 salt rounds
- Added in-memory rate limiting (5 attempts per hour per IP)
- Created user repository following repository pattern
- All 19 endpoint tests passing + 11 schema tests = 30 total tests passing
- Standardized error responses with {error: {code, message, details}} format
- Updated vitest config with proper SvelteKit path alias resolution

### File List
**Created:**
- `src/lib/server/repositories/user.ts` - User repository with findUserByEmail and createUser functions
- `src/lib/server/utils/rate-limit.ts` - In-memory rate limiting utility
- `src/routes/api/auth/register/+server.ts` - Registration API endpoint with POST handler
- `tests/api/auth/register.test.ts` - Comprehensive test suite (19 tests)

**Modified:**
- `vitest.config.ts` - Added $lib alias resolution for SvelteKit imports
- `package.json` - Added bcrypt, zod, and @types/bcrypt dependencies

## QA Results

### Review Date: 2025-10-27

### Reviewed By: Quinn (Test Architect)

### Risk Assessment: DEEP REVIEW
**Triggers Met:**
- ✓ Auth/security files touched (registration with password handling)
- ✓ Previous gate was CONCERNS (Story 1.2)
- ✓ Story has 8 acceptance criteria (threshold: >5)
- ✗ No issues with test count (19 comprehensive tests present)
- ✗ Diff size reasonable

**Review Depth:** Comprehensive analysis including security review, requirements traceability, NFR validation, and test architecture assessment.

### Code Quality Assessment

**Overall: EXCELLENT** with security considerations noted.

The implementation demonstrates strong engineering practices:
- Clean, well-structured endpoint with clear separation of concerns
- Comprehensive test coverage (19 tests, all passing)
- Proper use of repository pattern for database access
- Good error handling with standardized format
- Well-documented code with JSDoc comments

**Strengths:**
- All 8 acceptance criteria fully implemented and tested
- Proper password hashing with bcrypt (10 salt rounds)
- Rate limiting implemented (MVP-appropriate in-memory solution)
- Zod validation with clear error messages
- Repository pattern correctly applied
- Consistent error response format

**No Refactoring Performed:** Code is clean and well-structured as-is.

### Requirements Traceability

**AC1: POST /api/auth/register endpoint accepts email and password** → ✓ COVERED
- Test: `should register new user with valid email and password`
- Test: `should create user in database`
- Given: Valid email and password
- When: POST request to /api/auth/register
- Then: User created with 201 status

**AC2: Email validation (format + uniqueness)** → ✓ COVERED
- Test: `should reject invalid email format`
- Test: `should reject empty email`
- Test: `should reject missing email`
- Test: `should reject duplicate email with 409 status`
- Test: `should not modify original user when duplicate attempted`
- Given: Invalid or duplicate email
- When: Registration attempted
- Then: Appropriate 400/409 error returned

**AC3: Password validation (minimum 8 characters)** → ✓ COVERED
- Test: `should reject password less than 8 characters`
- Test: `should reject empty password`
- Test: `should reject missing password`
- Given: Password < 8 characters
- When: Registration attempted
- Then: 400 error with clear message

**AC4: Password hashing with bcrypt** → ✓ COVERED
- Test: `should hash password before storing`
- Test: `should store hash that bcrypt.compare can verify`
- Given: Plaintext password
- When: User created
- Then: Password hashed with bcrypt, not stored as plaintext

**AC5: Successful registration creates user and returns response** → ✓ COVERED
- Test: `should register new user with valid email and password`
- Test: `should not return password_hash in response`
- Given: Valid credentials
- When: Registration succeeds
- Then: User created, response excludes password_hash, 201 status

**AC6: Appropriate error responses (400, 409)** → ✓ COVERED
- Test: `should return standard error format for validation errors`
- Test: `should return standard error format for duplicate email`
- Test: `should use appropriate HTTP status codes`
- Given: Invalid input or duplicate email
- When: Error occurs
- Then: Standardized {error: {code, message, details}} format with correct status

**AC7: Basic rate limiting** → ✓ COVERED
- Test: `should allow 5 registration attempts`
- Test: `should reject 6th attempt with 429 status`
- Test: `should track rate limits per IP independently`
- Given: Multiple requests from same IP
- When: Limit exceeded
- Then: 429 error returned

**AC8: Unit tests cover validation and error cases** → ✓ COVERED
- 19 comprehensive tests across 7 test suites
- All edge cases, validation, security, and error scenarios covered

**Coverage Analysis:** 8/8 ACs fully covered with comprehensive test scenarios

### Compliance Check

- **Coding Standards:** ✓ COMPLIANT
  - ✓ Repository pattern for database access
  - ✓ Standardized error format {error: {code, message, details}}
  - ✓ Try-catch error handling
  - ✓ No raw SQL in API routes
  - ✓ Proper JSDoc documentation

- **Project Structure:** ✓ COMPLIANT
  - ✓ API routes in src/routes/api/auth/
  - ✓ Repositories in src/lib/server/repositories/
  - ✓ Utilities in src/lib/server/utils/
  - ✓ Tests in tests/api/auth/

- **Testing Strategy:** ✓ EXCELLENT
  - ✓ Comprehensive unit tests (19 tests)
  - ✓ All edge cases covered
  - ✓ Security scenarios tested
  - ✓ Proper test isolation with beforeEach/afterEach
  - ✓ Test helpers for request mocking

- **All ACs Met:** ✓ YES (8/8 acceptance criteria fully implemented)

### Test Architecture Assessment

**Coverage:** EXCELLENT (19 tests covering all requirements + edge cases)

**Test Level Appropriateness:** ✓ CORRECT
- Input validation → Unit tests (appropriate)
- Business logic (email uniqueness, password hashing) → Unit tests (appropriate)
- Rate limiting → Unit tests (appropriate)
- API endpoint behavior → Integration-style unit tests (appropriate)

**Test Design Quality:** EXCELLENT
- Clear, descriptive test names
- Proper setup/teardown (beforeEach/afterEach)
- Well-organized test suites by functionality
- Good use of test helpers (createRequest, createEvent)
- Tests are isolated and independent
- Realistic test data

**Edge Case Coverage:** COMPREHENSIVE
- ✓ Invalid email formats
- ✓ Missing required fields
- ✓ Short passwords
- ✓ Duplicate emails
- ✓ Rate limit boundaries
- ✓ Password not returned in response
- ✓ Password hashing verification
- ✓ Error response format consistency

**Test Data Management:** GOOD
- Cleanup with afterEach
- Rate limit reset for test isolation
- Independent IP addresses for rate limit tests

### Non-Functional Requirements (NFRs)

**Security: CONCERNS**
- ✓ Password hashing with bcrypt (10 salt rounds)
- ✓ Password never stored in plaintext
- ✓ Password never returned in API responses
- ✓ Input validation with Zod
- ✓ Rate limiting to prevent abuse
- ✓ Proper error handling (no stack traces exposed)
- ⚠️ **CONCERN:** Email enumeration vulnerability
  - Duplicate email error returns specific EMAIL_EXISTS code
  - Details include the attempted email
  - Allows attackers to determine which emails are registered
  - **Recommendation:** Use generic message or implement timing-safe responses
- ⚠️ **INFO:** No password complexity requirements beyond length (common, acceptable for MVP)
- ⚠️ **INFO:** Console.error logging in catch block (consider structured logging for production)

**Performance: PASS**
- ✓ Simple, efficient repository queries
- ✓ Minimal database round trips
- ✓ Async/await properly used
- ✓ No N+1 query problems
- ⚠️ **INFO:** In-memory rate limiting (acceptable for MVP, migrate to Redis for production scale)

**Reliability: PASS**
- ✓ Comprehensive error handling with try-catch
- ✓ Standardized error response format
- ✓ Graceful handling of database errors
- ✓ Rate limiting prevents abuse
- ✓ All error paths tested

**Maintainability: PASS**
- ✓ Clean, readable code structure
- ✓ JSDoc comments on all public functions
- ✓ Repository pattern for data access
- ✓ Clear separation of concerns
- ✓ Well-organized test suites
- ✓ Consistent naming conventions

### Security Review

**Overall Security Posture: STRONG** with one consideration

**Positive Security Practices:**
1. ✓ Password hashing with bcrypt (industry standard, 10 salt rounds)
2. ✓ Input validation with Zod (prevents injection attacks)
3. ✓ Rate limiting (prevents brute force attacks)
4. ✓ Password excluded from API responses
5. ✓ Proper error handling (no stack traces exposed)
6. ✓ Repository pattern (prevents SQL injection)

**Security Considerations:**
1. ⚠️ **Email Enumeration Vulnerability (Medium Severity)**
   - **Issue:** Duplicate email check returns EMAIL_EXISTS with email in details
   - **Impact:** Medium - Attackers can determine which emails are registered
   - **Likelihood:** High - Common attack vector for reconnaissance
   - **Recommendation:** Consider generic "registration failed" message or timing-safe responses
   - **Timeline:** Can be addressed in future story if team accepts risk for MVP

2. ℹ️ **Password Complexity:** Only length validated (no uppercase, numbers, special chars)
   - **Impact:** Low - 8-character minimum is reasonable for MVP
   - **Recommendation:** Consider stronger requirements for production

3. ℹ️ **Logging Sensitivity:** console.error logs full error details
   - **Impact:** Low - Could expose sensitive data in logs
   - **Recommendation:** Use structured logging with sanitization for production

**No Critical Security Issues Found**

### Performance Considerations

**Overall Performance: GOOD**

**Strengths:**
- Efficient Drizzle ORM queries
- Proper use of async/await
- Minimal database round trips
- Good request/response handling

**MVP Limitations (Acceptable):**
- In-memory rate limiting (loses state on restart)
- No caching layer (not needed for registration)

**Future Optimizations (Not Needed Yet):**
- Migrate rate limiting to Redis for production scale
- Add structured logging for better observability
- Consider rate limit per email (in addition to IP)

### Technical Debt Identified

**Total Debt Score: LOW** (well-implemented with documented MVP trade-offs)

1. **Email Enumeration Vulnerability** - Priority: MEDIUM
   - Issue: EMAIL_EXISTS response enables user enumeration
   - Effort: Low (change error message)
   - Impact: Medium (security reconnaissance)
   - Recommendation: Address before production or accept as known risk

2. **In-Memory Rate Limiting** - Priority: LOW (MVP-acceptable)
   - Issue: Rate limits reset on server restart
   - Effort: Medium (migrate to Redis)
   - Impact: Low (documented as MVP solution)
   - Recommendation: Migrate to Redis-based solution for production

3. **No Password Complexity Rules** - Priority: LOW
   - Issue: Only length validated (8 chars minimum)
   - Effort: Low (add Zod validators)
   - Impact: Low (8 chars is reasonable for MVP)
   - Recommendation: Consider adding for production

4. **Basic Error Logging** - Priority: LOW
   - Issue: console.error used instead of structured logging
   - Effort: Low (add logging library)
   - Impact: Low (acceptable for MVP)
   - Recommendation: Add structured logging (Pino) for production

### Improvements Checklist

**No Refactoring Performed (Code is excellent as-is)**

**Recommended for Team (Advisory, Not Blocking):**
- [ ] Consider generic error message for email existence checks to prevent enumeration
- [ ] Plan migration path for Redis-based rate limiting before production
- [ ] Add structured logging with Pino (per tech stack doc)
- [ ] Consider password complexity requirements (uppercase, numbers, special chars)
- [ ] Document accepted security trade-offs for MVP

### Files Modified During Review

**None** - No refactoring performed, code quality is excellent.

### Gate Status

**Gate: CONCERNS** → `docs/qa/gates/1.3-user-registration-endpoint.yml`

**Status Reason:** Excellent implementation with comprehensive tests. One medium security consideration regarding email enumeration vulnerability. Rate limiting documented as MVP solution. All functional requirements met with strong code quality.

**Quality Score:** 90/100
- Base: 100
- Concerns: -10 (1 medium issue × 10 points)
- Final: 90

**Evidence:**
- Tests Reviewed: 19 (all passing) + 11 existing = 30 total
- Risks Identified: 1 medium concern, 3 low technical debt items
- AC Coverage: 8/8 fully covered
- NFR Status: Security CONCERNS, Performance PASS, Reliability PASS, Maintainability PASS

### Recommended Status

**✓ APPROVED for Done** (with advisory note)

**Rationale:**
- All 8 acceptance criteria fully met and tested
- 19 comprehensive tests, all passing
- Code quality is excellent
- Repository pattern correctly applied
- Email enumeration concern is advisory (common MVP trade-off)
- In-memory rate limiting documented as MVP solution

**Advisory Note:** Email enumeration vulnerability noted but acceptable for MVP if team acknowledges risk. Consider generic error messages or timing-safe responses before production deployment.

**Story Team Decision:** Final status change is at story owner's discretion. This review recommends proceeding to Done with the noted advisory for future hardening.
